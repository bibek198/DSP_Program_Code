#include <stdio.h>
#include <math.h>

#define N 100
#define M 51
#define PI 3.14159265358979323846

float x[N], y[N];
float XR[N], XI[N];
float amplitude_in[N], amplitude_out[N];
float b[M], h_lp[M], h_hp[M];

// Low-pass FIR filter coefficients (given)
float h[51] = {
    -0.03012856352907, 0.07518556094106, 0.0347107415489, 0.020773388533,
    0.01458846949463, 0.009901508624105, 0.004815070324426, -0.0009912477392302,
    -0.007236113317258, -0.01328621421835, -0.01853229090741, -0.02212338859297,
    -0.02350058075885, -0.02208352290888, -0.01748432902234, -0.009758034457342,
    0.001093534289564, 0.01455515002771, 0.02991549107912, 0.04627745357896,
    0.06270133716713, 0.07800956621943, 0.09121853292119, 0.1013742672991,
    0.10783870071, 0.1100289455531, 0.10783870071, 0.1013742672991,
    0.09121853292119, 0.07800956621943, 0.06270133716713, 0.04627745357896,
    0.02991549107912, 0.01455515002771, 0.001093534289564, -0.009758034457342,
    -0.01748432902234, -0.02208352290888, -0.02350058075885, -0.02212338859297,
    -0.01853229090741, -0.01328621421835, -0.007236113317258, -0.0009912477392302,
    0.004815070324426, 0.009901508624105, 0.01458846949463, 0.020773388533,
    0.0347107415489, 0.07518556094106, -0.03012856352907
};

int main(void) {
    int i, j, n;

    //---------------------------
    // Step 1: Generate input signal
    //---------------------------
    for (i = 0; i < N; i++) {
        x[i] = 5 + (2 * sin(2 * PI * 30 * i / N)) + (3 * cos(2 * PI * 2 * i / N));
    }

    //---------------------------
    // Step 2: DFT of input signal
    //---------------------------
    for (j = 0; j < N; j++) {
        XR[j] = 0;
        XI[j] = 0;
        for (i = 0; i < N; i++) {
            XR[j] += x[i] * cos(2 * PI * i * j / N);
            XI[j] -= x[i] * sin(2 * PI * i * j / N);
        }
        amplitude_in[j] = sqrt(XR[j] * XR[j] + XI[j] * XI[j]);
    }

    //---------------------------
    // Step 3: Create High-Pass FIR using spectral inversion
    //---------------------------
    for (i = 0; i < M; i++) {
        h_lp[i] = h[i];
        h_hp[i] = -h_lp[i];  // Invert
    }
    h_hp[M / 2] += 1;  // Add delta[n] (center tap)

    //---------------------------
    // Step 4: Apply High-Pass FIR filter
    //---------------------------
    for (n = 0; n < N; n++) {
        y[n] = 0;
        b[0] = x[n];
        for (i = M - 1; i > 0; i--) {
            b[i] = b[i - 1];
        }
        for (i = 0; i < M; i++) {
            y[n] += h_hp[i] * b[i];
        }
    }

    //---------------------------
    // Step 5: DFT of filtered signal
    //---------------------------
    for (j = 0; j < N; j++) {
        XR[j] = 0;
        XI[j] = 0;
        for (i = 0; i < N; i++) {
            XR[j] += y[i] * cos(2 * PI * i * j / N);
            XI[j] -= y[i] * sin(2 * PI * i * j / N);
        }
        amplitude_out[j] = sqrt(XR[j] * XR[j] + XI[j] * XI[j]);
    }

    //---------------------------
    // Step 6: Display Results
    //---------------------------
    printf("\nHigh-Pass FIR Filter Output (first 10 samples):\n");
    for (i = 0; i < 10; i++)
        printf("y[%d] = %.6f\n", i, y[i]);

    return 0;
}
